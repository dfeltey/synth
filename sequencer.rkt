#lang typed/racket

(require math/array racket/flonum racket/unsafe/ops)

(require "synth.rkt" "mixer.rkt")

(define-type NoteName (U 'C  'C# 'Db 'D 'D# 'Eb 'E 'F 'F#
                         'Gb 'G  'G# 'Ab 'A  'A# 'Bb 'B))
;; should add a ModeName type as well

(provide scale chord note sequence mix)



(define-type Chord (Pairof (Listof Integer) Integer))
(define-type SingleNote (Pairof Integer Integer))
(define-type Pause (Pairof #f Integer))

(define (base+relative-semitone->freq base relative-semitone)
  (* 440 (expt (expt 2 1/12) -57)))

;; details at http://www.phy.mtu.edu/~suits/notefreqs.html
(: note-freq (Integer -> Float))
(define (note-freq note)
  ;; A4 (440Hz) is 57 semitones above C0, which is our base.
  (real->double-flonum (* 440 (expt (expt 2 1/12) (- note 57))))) 

;; A note is represented using the number of semitones from C0.
(: name+octave->note (NoteName Integer -> Integer))
(define (name+octave->note name octave)
  (+ (* 12 octave)
     (case name
       [(C) 0] [(C# Db) 1] [(D) 2] [(D# Eb) 3]  [(E) 4] [(F) 5] [(F# Gb) 6]
       [(G) 7] [(G# Ab) 8] [(A) 9] [(A# Bb) 10] [(B) 11] 
       [else (error "invalid note")]))) 

;; Generates a scale of the given mode (major, minor, ...) starting at
;; `root' at `octave'. `duration' is the duration of an individual note.
;; Custom scales can be generated by giving a list of semitone intervals.
;; Returns a list of note + duration pairs
;; TODO add option for descending
(: scale (NoteName Integer Integer Any Integer * -> (Listof SingleNote)))
(define (scale root octave duration mode . notes*)
  (define root-note (name+octave->note root octave))
  (define: notes : (Listof Integer)
    (if (eq? mode 'custom)
        notes*
        (case mode
          ((major ionian)                '(0 2 4 5 7 9 11 12))
          ((minor minor-natural aeolian) '(0 2 3 5 7 8 10 12))
          ((minor-harmonic mohammedan)   '(0 2 3 5 7 8 11 12))
          ((minor-melodic)               '(0 2 3 5 7 9 11 12))
          ((dorian)                      '(0 2 3 5 7 9 10 12))
          ((phrygian)                    '(0 1 3 5 7 8 10 12))
          ((lydian)                      '(0 2 4 6 7 9 11 12))
          ((mixolydian)                  '(0 2 4 5 7 9 10 12))
          ((locrian)                     '(0 1 3 5 6 8 10 12))
          ((major-arpeggio)              '(0 4 7))
          ((minor-arpeggio)              '(0 3 7))
          ((custom)                      notes*)
          (else (error "invalid mode"))))) 
  (for/list: : (Listof SingleNote)
    ([n (in-list notes)])
    (cons (+ root-note n) duration)))
;; TODO probably leave duration out of this (and chord) for now, and have it
;;  be part of a higher-level API



;; Similar to scale, but generates a chord.
;; Chords are pairs (listof note) + duration
(: chord (NoteName Integer Integer Any Integer * -> Chord))
(define (chord root octave duration type . notes*)
  (: notes (Listof SingleNote))
  (define notes (apply scale root octave duration type notes*))
  (cons ((inst map Integer SingleNote) car notes) duration))


;; Single note.
(: note (NoteName Integer Integer -> SingleNote))
(define (note name octave duration)
  (cons (name+octave->note name octave) duration))


;; Accepts notes or pauses, but not chords.
(: synthesize-note ((Option Integer) Integer (Float -> (Indexes -> Float)) -> (Array Float)))
(define (synthesize-note note n-samples function)
  (build-array (vector n-samples)
               (if note
                   (function (note-freq note))
                   (lambda (x) 0.0)))) ; pause


(define-type Pattern (U SingleNote Chord Pause))
(define-type PatternList (Listof Pattern)) 

;; repeats n times the sequence encoded by the pattern, at tempo bpm
;; pattern is a list of either single notes (note . duration) or
;; chords ((note ...) . duration) or pauses (#f . duration) 
(: sequence (Integer PatternList Integer (Float -> (Indexes -> Float)) -> (Array Float)))
(define (sequence n pattern tempo function)
  (: samples-per-beat Integer)
  (define samples-per-beat (quotient (* fs 60) tempo)) 
  (array-append*
   (for*/list: : (Listof (Array Float))
     ([i : Integer (in-range n)] ; repeat the whole pattern 
      [note : Pattern (in-list  pattern)])
     (if (list? (car note)) ; chord
         (apply mix
                (for/list: : (Listof Weighted-Signal)
                  ([x (in-list (car note))])
                  (list (synthesize-note x
                                         (* samples-per-beat (cdr note))
                                         function)
                        1))) ; all of equal weight
         (synthesize-note ((inst car (Option Integer) Integer) note)
                          (* samples-per-beat (cdr note))
                          function)))))
